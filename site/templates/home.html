{% extends "base.html" %}
{% block content %}
<h1><a href="/article/ppdd">Politics, Programming, Data and the Drogulus</a></h1><p class="published_on">Saturday 18th May 2013 (4:00PM)</p>
<p><small>(This article is based upon a short talk I gave at
<a href="http://www.opentech.org.uk/2013/">Opentech</a> 2013.)</small></p>

<p><img src="/static/images/drogulus.png" alt="Drogulus logo"/></p>

<p>The drogulus is a simple data store and computation platform that I've been
hacking on, as a side project, in my spare time. It's also a speculative
exercise in decentralisation and a reaction to the current state of the
<a href="https://en.wikipedia.org/wiki/World_Wide_Web">web</a>.
It's a political exercise too: the drogulus promotes a certain point of view
about technology's role in society - a programmer's attempt to promote autonomy
and liberate data. Finally, it's a project that gives me a place to explore
ideas that have been knocking around inside my head for a while.</p>

<p>I tell myself, "it'll all come to nothing" but I'm having too much fun to
stop, so I want to tell you about the drogulus to give you a sense of why I
find it so fascinating.</p>

<p>It started when I tried to articulate my growing unease with the web. I
arrived at three problems:</p>

<ol>
    <li><em>Users are no longer in control (of their digital assets or
    identity)</em> - In order to publish anything on the web most users
    need third party web sites to curate data on their behalf. These are the
    notorious walled gardens that lock in data and make it hard to migrate to
    other services. Furthermore, each website requires its own set of
    credentials to identify the user making it hard to tell that the provenance
    of data on one service is the same as that on yet another. Baroque
    technological solutions have been proposed to solve such problems but these
    are merely a manifestation of problem #2.</li>

    <li><em>Hackers (used in the positive sense of the word) are obstructed
    by incumbent technology from tackling problems with elegant, useful and
    joyful solutions</em> - The beautifully simple hypertext system
    originally envisioned by Tim Berners-Lee has grown into a monster. It's a
    plethora of complex technologies specified by committee that run on quirky
    browsers which never behave consistently. Furthermore, the web's
    decentralized nature has been undermined: large parts of it go dark when
    certain hosting providers break down or if popular websites fall over - the
    inevitable result of reliance on centralised services and a manifestation
    of problem #3.</li>

    <li><em>The web, as it exists today, contains many inadvertent points of
    control, lock-in and authority each of which is a potential mechanism for
    dis-empowerment and exploitation</em> - This highlights fundamental
    political and ethical problems concerning control, privacy and
    participation. Much of this is due to the web's client/server architecture:
    it promotes centralisation of power and single points of failure. Such
    potential dis-empowerment even extends to political and legal manipulations
    of <a href="https://en.wikipedia.org/wiki/Domain_Name_System">DNS</a> - the
    mechanism for linking domains to the computers that host websites.</li>
</ol>

<p>These problems are contrary a concept that is very important to me:
autonomy.</p>

<p>For me, when someone or something is autonomous it is self-directing, free
to act of its own accord and lacking imposition or direct control from external
parties. It also suggests intelligence and awareness enough to be able to enjoy
and make use of such freedom. Furthermore, such intelligence entails ethical
and political considerations on the part of the someone or something - they
become accountable for their actions. Autonomy is also the opposite of such
undesirable states as tyranny, slavery, ignorance and apathy.</p>

<p>I wondered how a networked technology designed to promote autonomy would
function. Would it be possible to create a simple yet useful foundation within
which others could build, collaborate and share data without prejudice?
Furthermore, it should be possible to demonstrate a reasonable movement of
thought from ethical and political considerations via technical requirements to
a working solution. I started to hack, and the drogulus was born.</p>

<p>The drogulus is a global federated, decentralized and openly writeable data
store and computation platform that includes mechanisms for provenance and
trust via
<a href="https://en.wikipedia.org/wiki/Public-key_cryptography">public key
cryptography</a>.</p>

<p>Being federated (the system consists of many independent but collaborating
entities) and decentralized (no entity is more important than any of the
others) ensures users are free from choke points of authority that may be used
to control access to data and usage of the system.</p>

<p>Being openly writeable ensures no user is barred from the system. All users
are free to contribute, change, enhance and expand the system without
prejudice.</p>

<p>Being a distributed computation platform means users can do something useful
with the data stored in the drogulus. By distributed computation I mean
asynchronously running programs on peers in the network without having to
rely on intermediaries to provide such services. Imagine it as a sort of
reconfigurable <a href="http://setiathome.ssl.berkeley.edu/">SETI@home</a> on
steroids: by running a drogulus peer you are sharing a small amount of your
potential computing power with everyone else on the network).</p>

<p>Having a cryptographic mechanism for provenance allows users of the drogulus
to identify each other and build trust whilst retaining control of data without
a reliance upon external parties.</p>

<p>So, how does it work? The drogulus has three core components:</p>

<ul>
  <li>A
  <a href="https://en.wikipedia.org/wiki/Distributed_hash_table">distributed
  hash table</a> (DHT) that provides the data store and replaces DNS.</li>
  <li>Trust and identity enforced via
  <a href="https://en.wikipedia.org/wiki/Digital_signature">cryptographic
  signing</a> of digital assets.</li>
  <li>Logos
  (<a href="https://en.wikipedia.org/wiki/Logos">&#955;&#972;&#947;&#959;&#962;</a>),
  a simple
  <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a>
  like programming language for asynchronously working with data stored in the
  DHT.</li>
</ul>

<p>The gist of a distributed hash table is that it works like a sort of
universal dictionary: a unique key is used to identify some value. In the case
of a traditional dictionary, the key is a word and the associated value is
its definition. However, a distributed hash table allows users to create new
keys and values (where the values can be any sort of digital asset).
Furthermore, the hash table is split in to the equivalent of the many volumes
of a traditional dictionary. Each person who ever uses the dictionary has a
copy of just one such volume - although there will be many copies of each
volume given to many different users. Finally, users of the dictionary keep
track of which of their friends hold what volume. To look up or store a value
users simply contact a friend with the correct volume containing the desired
key. If they don't know a person with the right volume then they play a sort of
<a href="https://en.wikipedia.org/wiki/Six_degrees_of_separation">six-degrees-of-separation</a>
game with their friends until someone with the correct volume is found.
Distributed hash tables also share an interesting property with
<a href="http://www.bittorrent.com/">Bittorrent</a>: the more popular an entry
is the more widespread it becomes, thus improving performance since popular
items are easier to find.</p>

<p>The drogulus implements a version of the
<a href="https://en.wikipedia.org/wiki/Kademlia">Kademlia</a> distributed hash
table. The innovation the drogulus brings is that keys and values are
cryptographically signed in such a way that their provenance can be proven and
content shown to be "intact" (i.e. not tampered with) in a similar way that you
might use <a href="https://en.wikipedia.org/wiki/Pretty_Good_Privacy">PGP</a>
to sign email. Values that do not pass the cryptographic checks are ignored and
nodes on the network that attempt to propagate such values are punished by
being blocked.</p>

<p>Logos is a
<a href="https://en.wikipedia.org/wiki/Homoiconicity">homoiconic</a> language:
Logos programs can rewrite other Logos programs in order to extend the Logos
programming language itself. This is an important property: users have the
autonomy to grow the Logos language to suite their own needs. Furthermore,
Logos programs are themselves values stored within the DHT so users can re-use
each other's code. They run in asynchronous "ensembles" on peers in the
drogulus that eventually arrive at a consensus from processing items of data
(including other programs) stored within the DHT. Logos programs are
<a href="https://en.wikipedia.org/wiki/Sandbox_(computer_security)">sandboxed</a>
and intentionally limited in terms of time (how long a computation may last)
and space (how much memory may be used) to protect the collaborating peers from
nefarious code.</p>

<p>Currently, the DHT is almost finished, the cryptographic layer is done and
Logos is in the advanced planning stages with some experimental code
written.</p>

<p>So far, the drogulus is an academic exercise and playtime for me during
my daily commute. Also, because I'm working at such an abstract level it's
hard for me to comprehend what use others may find for a global, decentralised
data store and computation platform. That's why I wanted to present the
drogulus in its current incomplete state: to gauge what sort of reaction it
might get.</p>

<p>I'll finish by pointing out that in 1996
<a href="https://en.wikipedia.org/wiki/William_Gibson">William Gibson</a>
described the web as merely the
<a href="http://www.nytimes.com/1996/07/14/magazine/the-net-is-a-waste-of-time.html?pagewanted=all">test card for 21st century technology</a>.
We will only have ourselves to blame if we don't imagine and attempt to build
something better than the test card that is the web. After all, if there's one
thing that the web has taught us, it is that engineering software is a far more
useful, tangible and easier agent of change than traditional means of political
engagement.</p>

<p>The code is on <a href="http://github.com/ntoll/drogulus">GitHub</a> and
I've created a simple <a href="http://drogul.us">website</a> that explains
things further. If you have any questions please drop me an
<a href="/contact">email</a>.</p>

<p>Thanks!</p>

<p><small>Image credits: &copy; the author.</small></p>
<hr/>
<h1><a href="/article/long-term-view">Taking the Long Term View</a></h1><p class="published_on">Thursday 28th March 2013 (8:00AM)</p>

<p>The <a href="http://www.britishmuseum.org/">British Museum</a> is one of my
favourite places because it forces me to take on a perspective of 5000 years
or more. Take the
<a href="http://www.britishmuseum.org/explore/highlights/highlight_objects/me/t/tablet,_allocation_of_beer.aspx">Mesopotamian clay tablet</a>
shown below: it records the allocation of beer by administrators in the city
of <a href="https://en.wikipedia.org/wiki/Uruk">Uruk</a>. The symbol
representing beer is apparently an upright jar with a pointed base, amounts
are notated by circles and semi-circles and, at the bottom left, there is a
figure drinking from a bowl.</p>

<img src="/static/images/15_writingtablet_l.jpg" alt="Mesopotamian tablet"/>

<p>It's about 5100 years old. Now, pause for a moment to consider its age.</p>

<p>The difference in time between today and the era of
<a href="https://en.wikipedia.org/wiki/Julius_Caesar">Julius Caesar</a> and
<a href="https://en.wikipedia.org/wiki/Cleopatra_VII_of_Egypt">Cleopatra</a>
is 1000 years less than the period between the creation of the Mesopotamian
tablet and the era of Caesar and Cleopatra. Put simply, Caesar and Cleopatra
are closer in time to us (by 1000 years) than they are to the Mesopotamian
scribe who recorded the allocation of beer to citizens of Uruk.</p>

<p>It is intriguing that the tablet is political in nature, an instance
of a new technology and of economic interest. Not only is it evidence of the
machinations of the state in Uruk but it demonstrates how a new technology
(writing) changed the capabilities of such a state: for the first time it was
possible to keep records and thus run a bureaucracy on a large scale.
Furthermore, it records receipt of payment requiring concepts such as balance,
debt and a measure of value (in beer).</p>

<p>Such concepts (writing, state bureaucracy and fundamental economics) are
unremarkable in today's world, making it difficult for us to appreciate how
important, strange or unusual they must have seemed when they first appeared. I
wonder what important, strange or unusual aspects of our time will be
unremarkable to our descendants. Furthermore, what aspects of our lives that
seem fixed today will be completely different 5000 years hence?</p>

<p>Guessing the future is a fool's game. As
<a href="http://en.wikipedia.org/wiki/Alan_Kay">Alan Kay</a> famously
stated,</p>

<blockquote>"The best way to predict the future is to invent it."</blockquote>

<p>Something from today that "<em>invents the future</em>" is
programming, and I'm guessing the
<a href="http://www.informatimago.com/develop/lisp/com/informatimago/small-cl-pgms/wang.html">Lisp program from 1960</a>
copied below is our Mesopotamian tablet for future generations:</p>

<p><pre><code class="lisp">(shadow '(trace untrace))
(defun trace   (functions) (eval `(cl:trace   ,@functions)))
(defun untrace (functions) (eval `(cl:untrace ,@functions)))

(defun define (definitions)
  (dolist (def definitions)
    (eval (if (and (consp (second def)) (eq 'lambda (car (second def))))
              `(progn (defun        ,(first def) ,@(cdr (second def)))
                      (defparameter ,(first def) ,(second def)))
              `(defparameter ,(first def) ,(second def))))))

(defun stop (arguments) (throw 'driver-end-of-deck nil))
(defun fin  (arguments) (throw 'driver-end-of-deck nil))
(defun test (arguments) (princ arguments) (terpri))

(defun driver (path)
  (with-open-file (cards path)
    (catch 'driver-end-of-deck
      (loop (let ((first-char (read-char cards)))
              (if (char= #\* first-char)
                  (read-line cards)     ; comment
                  (progn
                    (unread-char first-char cards)
                    (let* ((command   (read cards))
                           (arguments (if (member command '(stop fin test))
                                          (list (read-line cards))
                                          (read cards))))
                      (print (apply command arguments))))))))))</code></pre></p>


<p>Despite this code being more than 50 years old, it is still understandable
to anyone who has read my
<a href="/article/lisp-concise-and-simple">recent Lisp article</a>. Furthermore
it forces me to wonder what the computational world will be like in 5000 years.
I hope the <a href="/article/the-web-concise-and-simple">world wide web</a>
will be long gone and replaced with something much more capable and better
engineered and I guess that new computer architectures will arise to replace
the
<a href="https://en.wikipedia.org/wiki/Von_Neumann_architecture">Von Neumann</a>
/ <a href="https://en.wikipedia.org/wiki/Harvard_architecture">Harvard</a>
based models in current use.</p>

<p>Perhaps the final word should be another Alan Kay quote:</p>

<blockquote>"I believe that the only kind of science computing can be is like
the science of bridge building. Somebody has to build the bridges and other
people have to tear them down and make better theories, and you have to keep
on building bridges."</blockquote>

<p><small>Image credits: Mesopotamian tablet
&copy; <a href="http://www.britishmuseum.org/">Trustees of the British Museum</a>
</small></p>
<hr/>
<h1><a href="/article/minecraft-pi">Programming Minecraft on the RaspberryPi</a></h1><p class="published_on">Thursday 16th March 2013 (10:45PM)</p>

<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/MmB9b5njVbA?rel=0" frameborder="0" allowfullscreen></iframe>

<p><a href="http://minecraft.net/">Minecraft</a> is a sort of digital Lego.
Players explore a blocky computer generated world and have the ability to build
new terrain, buildings and other features. Many users have generated creative
and complicated structures within their games by carefully placing individual
bricks (just like Lego). A quick
<a href="https://www.google.com/search?q=minecraft&hl=en&source=lnms&tbm=isch">Google image search for Minecraft</a> will return lots of amazing results.</p>

<p>The <a href="http://www.raspberrypi.org/">RaspberryPi</a> is a cheap
computer designed to encourage kids (of all ages) to learn how to program.
Apparently, the "pi" part of the name is a misspelled reference to the
<a href="http://python.org">Python</a> programming language - the RaspberryPi's
principal programming language for education.</p>

<p>Minecraft is amazingly popular among kids (my own included). I guess, like
Lego, it's the potential for creative generative play that is so appealing.
Wouldn't it be great if there were a version of Minecraft that you could
program in Python that ran on the RaspberryPi..?</p>

<p><a href="http://pi.minecraft.net/">THERE IS!</a></p>

<p>I'm currently at <a href="https://us.pycon.org/2013/">PyconUS 2013</a> in
California, every attendee has been given a RaspberryPi and there's a
RaspberryPi lab in which attendees are encouraged to try their new piece of
kit. I just spent a fun morning programming Minecraft with Python. What follows
is a quick "how to" guide to get you started.</p>

<p>I'll assume you've got a RaspberryPi to hand and that it's connected to the
internet. (If you're unsure how to do this I suggest you visit the main
<a href="http://raspberrypi.org/">RaspberryPi website</a> for more
information.)</p>

<p>First you should <a href="http://pi.minecraft.net/?page_id=10">download the
RaspberryPi version of Minecraft</a> and follow the instructions at the web
page to which I just linked.</p>

<p>Next, once you have Minecraft running on your RaspberryPi I suggest you play
for a while. Create a world and have a look around. Here's a run-down of the
commands you can use:</p>

<ul>
    <li>Keyboard
        <ul>
            <li>W,A,S,D - Move (or navigate inventory)</li>
            <li>SPACE - Jump, double tap to start/stop flying, hold to fly
            higher</li>
            <li>SHIFT - Sneak, hold to fly lower</li>
            <li>E - Open inventory</li>
            <li>1-8 - Select inventory slot item to use</li>
            <li>ESC - Show/hide menu</li>
            <li>TAB - Release mouse without showing menu</li>
            <li>ENTER - Confirm menu selection</li>
        </ul>
    </li>
    <li>Mouse
        <ul>
            <li>Steer - Look/turn around</li>
            <li>Left mouse button - Remove block (hold)</li>
            <li>Right mouse button - Place block, hit block with sword</li>
            <li>Mouse wheel - Select inventory slot item to use</li>
        </ul>
    </li>
</ul>

<p>Cool huh..?</p>

<p>But wouldn't it be fun to be able to program and automate the manipulation
of the game world with Python..?</p>

<p>Here's how to get started...</p>

<p>Open a terminal and change in to the Minecraft directory
(<code>mcpi</code>) within which you'll see a child directory called
<code>api</code> within which is yet another called <code>python</code>. From
within the <code>python</code> directory start Python by typing,
<code>python</code>.</p>

<p>Now, type in the following:</p>

<p><pre><code class="python">&gt;&gt;&gt; from mcpi import minecraft
&gt;&gt;&gt; mc = minecraft.Minecraft.create("127.0.0.1")
&gt;&gt;&gt; mc.postToChat("Hello, World!")
</code></pre></p>

<p>You should see the message <em>Hello, World!</em> pop up in the Minecraft
world. Congratulations, you've just programmed Minecraft!</p>

<p>The first command imported all the things that Python needs to talk to the
Minecraft game. The second line creates an object called <code>mc</code> that
represents a connection to your game. The third line sends the chat message
to the game.</p>

<p>How about building things within the Minecraft world..? Check this out...</p>

<p><pre><code class="python">&gt;&gt;&gt; from mcpi import block
&gt;&gt;&gt; mc.player.getTilePos()
Vec3(37,0,-39)
&gt;&gt;&gt; mc.setBlock(38, 0, -38, block.STONE_BRICK.id)
</code></pre></p>

<p>On the first line I import information Python needs about the blocks that
you can place within the Minecraft world. Next, I ask the game where in the
world my player is located. The game responds with an <em>x</em>, <em>y</em>
and <em>z</em> based location expressed as a vector. Finally, I use the
<code>setBlock</code> method to place a stone brick on an adjacent square.
If you take a look around you'll see it right next to you!</p>

<p>Actually, you will see different results to me because your player will be
stood in a different location. See if you can change the final line to place
a block close to your own player's location.</p>

<p>That's it (for now) and covers pretty much all I found out in the first 15
minutes of hacking about. If you want to explore the API further I suggest you
look at the <code>mcpi_protocol_spec.txt</code> file in the
<code>mcpi/api/spec</code> directory.</p>

<p>Personally, I think this is a gift horse that teachers everywhere should be
looking at in the mouth.</p>

<p>I'll blog some more about this when I get back to the UK.</p>

<p><a href="/articles">View all articles</a></p>
{% endblock content %}