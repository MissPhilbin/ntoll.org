{% extends "base.html" %}
{% block content %}
<h1><a href="/article/hide">Nothing to hide..?</a></h1><p class="published_on">Monday 19th May, 2014 (06:00PM)</p>

<p>On several occasions I have had to explain my position on privacy and
surveillance (especially in a digital context). To save me the task of
repeating myself, here it is in as simple a form as possible.</p>

<p>"If you have nothing to hide, you have nothing to fear" is a common
argument in support of the mass surveillance of citizens by the government or
the harvesting of user data by private corporations. Often it is made in a
reassuring manner, as demonstrated by
<a href=https://en.wikipedia.org/wiki/William_Hague">William Hague</a>:</p>

<iframe width="560" height="315" src="//www.youtube.com/embed/lWam4EWI48M" frameborder="0" allowfullscreen></iframe>

<p>A common re-statement of the argument goes, "only if you're doing something
wrong should you worry, and then you don't deserve to keep it private".</p>

<p>I'm guessing many people will immediately sympathise with these sentiments.
After all, we don't want the bad guys to gain the upper hand, you're probably
a fine upstanding citizen and we should be happy that innocents are protected
from the evil-doers that such a drag net will identify.</p>

<p>I beg to differ.</p>

<p>For a start, this position is a classic
<a href="https://en.wikipedia.org/wiki/False_dilemma">false dichotomy</a>:
two seemingly black and white choices are given yet there are many ways to
address the subject. Such either/or thinking excludes the potential for
a more nuanced and subtle debate. Furthermore, such false dichotomies are a
favourite tactic in argument and, unless you know what you're looking for,
can hoodwink many who take things at face value and stifle debate.</p>

<p>Leaving this aside, the actual choices presented in the argument hide
various nasty "home truths":</p>

<ul>
    <li><em>It's not you who determines if you have anything to hide</em>.
    It doesn't matter how upstanding a citizen you think
    <em>you</em> are; your point of view doesn't matter in this context since
    it's the law or (more dangerously) public opinion that judges you (viz.
    misjudged attacks on paediatricians). For example, teenagers growing up
    in the
    <a href="https://en.wikipedia.org/wiki/Eastern_Bloc">Eastern Bloc</a> had
    to hide their enjoyment of "corrupting capitalist music" (such as Rock and
    Roll). While one's taste in music is a relatively harmless attribute
    please consider the plight of
    <a href="https://en.wikipedia.org/wiki/LGBT_rights_in_Singapore">LGBT</a>
    persons living in Singapore and elsewhere who risk legal challenges and
    remember the many curtailments of religious freedoms throughout
    history.</li>

    <li><em>It assumes surveillance results in correct data and sound
    judgement.</em> People make mistakes and sometimes agents of the state
    or employees of corporations are <em>really stupid</em> and don't act in
    the public or customer's interest. For example, remember the
    <a href="https://en.wikipedia.org/wiki/Twitter_Joke_Trial">Twitter joke
    trial</a>? Given the context of the tweet it was obviously a joke, but
    the Police interpreted it differently. Is demonstrating a sense of humour
    a crime? I'd argue it's a healthy sign of a liberal tradition of free
    speech.</li>

    <li><em>Rules change.</em> For example, the UK's
    <a href="https://en.wikipedia.org/wiki/Regulation_of_Investigatory_Powers_Act_2000">RIPA</a>
    law gives the government powers to investigate and intercept
    communications on the grounds of <em>national security</em>. Sounds
    reasonable. Yet the number of public authorities empowered to use this
    legislation has increased four times (in 2003, 2005, 2006 and 2010) and
    many such bodies use their powers for totally unintended things (such as
    <a href="http://www.telegraph.co.uk/news/uknews/1584808/Council-spy-cases-hit-1000-a-month.html">tracking dog fouling</a>).
    The result is supposedly water-tight legislation being subverted by local
    councils (I hardly think dog shit is an issue of national security).</li>

    <li><em>Breaking the law isn't necessarily bad.</em>
    <a href="https://en.wikipedia.org/wiki/Gandhi">Mohandas Ghandi</a>,
    <a href="https://en.wikipedia.org/wiki/Emmeline_Pankhurst">Emmeline Pankhurst</a>,
    <a href="https://en.wikipedia.org/wiki/Jesus">Jesus</a>,
    <a href="https://en.wikipedia.org/wiki/Nelson_Mandela">Nelson Mandela</a>,
    <a href="https://en.wikipedia.org/wiki/Socrates">Socrates</a>, and
    [insert any well known and well respected historical person who many
    believe have been a beacon of hope, progress and morality] all broke the
    law.  The law is often an Ass and breaking it is often the only way in
    which "progress" is made. Imagine how such persons and the causes they
    represent would have thrived in a digital
    <a href="https://en.wikipedia.org/wiki/Panopticon">panopticon</a>.
    (They wouldn't.)</li>

    <li><em>Those who say privacy is dead are the ones that gain the most from
    surveillance.</em> This one's rather obvious but worth re-stating. Perhaps
    I'm being cynical, but when the CEOs of Facebook and Google both state
    <a href="http://www.switched.com/2010/01/11/facebooks-mark-zuckerberg-claims-privacy-is-dead/">privacy is dead</a>
    you've got to wonder if this has something to do with their business
    interests (where they sell your data through targeted advertising).</li>

    <li><em>Privacy is a fundamental human right.</em> Yes, I realise this is
    an argument from authority - specifically, the UN's
    <a href="https://www.un.org/en/documents/udhr/">universal declaration of
    human rights</a> - but I believe (and I'm guessing you do too) that
    intimate declarations of love, doctors discussing a patient, engineers
    developing a new top secret world changing product and journalists
    planning an expos&eacute; of government corruption are just a few scenarios
    where privacy is both a reasonable and legitimate requirement.</li>
</ul>

<p>Am I suggesting <em>privacy trumps all</em>? No. I would strongly argue
for openness when it comes to public institutions, the machinations of
government, our political representatives and corporations that deal with
personal data. How else are we to hold such entities to account?</p>

<p>Am I saying there should be <em>no surveillance</em>? Of course not, that
would be silly: I can think of plenty of legitimate reasons for surveillance
but <strong>none of them legitimise the
<a href="https://en.wikipedia.org/wiki/PRISM_%28surveillance_program%29">blanket surveillance of everyone</a></strong>.
Furthermore, I'm not the only one who
<a href="https://en.wikipedia.org/wiki/Fourth_Amendment_to_the_United_States_Constitution">believes this</a>:</p>

<blockquote>The right of the people to be secure in their persons, houses,
papers, and effects, against unreasonable searches and seizures, shall not be
violated, and no Warrants shall issue, but upon probable cause, supported by
Oath or affirmation, and particularly describing the place to be searched,
and the persons or things to be seized.
</blockquote>

<p>Yes, I know, the irony isn't lost on me either.</p>

<p>This article was written in haste over lunch and tidied up after
work. Think of it as a first draft and please feel free to take pot shots -
<a href="/contact">I welcome</a> constructive comments, critique and
ideas. ;-)</p>

<p><strong>EDIT #1</strong></p>

<p>A detective I know has pointed out that,</p>

<blockquote>Ripa isn't (and never was) just for national security, that is only one part of the act.</blockquote>

<p>I stand corrected! :-)</p>

<p>I was trying to demonstrate how laws can suffer from "scope creep":
once legitimate and sensible legislation being used in quite unintended and
nefarious ways. My detective buddy (who also happens to have a
philosophy degree and is exactly the sort of ethical, thoughtful and smart
person you'd hope would be working as a detective) understood exactly what I
was getting at so pointed out that,</p>

<blockquote>Law creep might be better with terrorism stop and search powers
where more people are stopped and searched without any actual individual
justification. That seems a more clean cut issue to my mind; specific powers
being used to blanket cover areas.

Or laws set up to manage serious sex offenders also catching idiots - the guy
who drops his trousers while drunk on a night out in town now has to notify
any change of address and register as a sex offender!
</blockquote>

<p>Great stuff!</p>
<hr/>
<h1><a href="/article/asyncio">Asynchronous Python</a></h1><p class="published_on">Monday 28th April, 2014 (12:30PM)</p>

<p><a href="http://python.org/">Python</a> version 3.4 was recently released.
For me, the most interesting
<a href="https://docs.python.org/3.4/whatsnew/3.4.html">update</a>
was the inclusion of the
<code><a href="http://legacy.python.org/dev/peps/pep-3156/">asyncio</a></code>
module. The
<a href="https://docs.python.org/3.4/library/asyncio.html">documentation</a>
states it,</p>

<blockquote>...provides infrastructure for writing single-threaded concurrent
code using coroutines, multiplexing I/O access over sockets and other
resources, running network clients and servers, and other related primitives.
</blockquote>

<p>While I understand all the terminology from the documentation I don't yet
have a <em>feel</em> for the module nor do I yet comprehend when to use one
feature rather than another. Writing about this module and examining
concrete examples is my way to
<a href="https://en.wikipedia.org/wiki/Grok">grok</a>
<code>asyncio</code>. I'll be concise and only assume familiarity with
Python.</p>

<p>So, what is <code>asyncio</code>?</p>

<p>It's a module that enables you to write code that concurrently handles
asynchronous network based interactions.</p>

<p>What precisely do I mean?</p>

<p>Concurrency is when several things happen simultaneously. When something is
asynchronous it is literally not synchronised: there is no way to tell when
some <em>thing</em> may happen (in this case, network based I/O).
<a href="https://en.wikipedia.org/wiki/Input/output">I/O</a> (input/output)
is when a program communicates with the "outside world" and network based I/O
simply means the program communicates with another device (usually) on the
internet. Messages arrive and depart via the network at unpredictable times -
<code>asyncio</code> helps you write programs that deal with all these
interactions simultaneously.</p>

<p>How does it work?</p>

<p>At the core of <code>asyncio</code> is an
<a href="http://hg.python.org/cpython/file/4ab2d8fac52b/Lib/asyncio/base_events.py#l176">event loop</a>.
This is simply code that keeps looping (I'm trying to avoid the
temptation of using a racing car analogy). Each "lap" of the loop (dammit)
checks for new I/O events and does various other "stuff" that we'll come onto
in a moment. Within the <code>asyncio</code> module, the
<a href="http://hg.python.org/cpython/file/4ab2d8fac52b/Lib/asyncio/base_events.py#l761">_run_once</a>
method encapsulates a full iteration of the loop. Its documentation
explains:</p>

<blockquote>This calls all currently ready callbacks, polls for I/O,
schedules the resulting callbacks, and finally schedules
'call_later' callbacks.
</blockquote>

<p>A <em>callback</em> is code to be run when some event has occurred and
<em>polling</em> is discovering the status of something external to the
program (in this case network based I/O activity). When a small child
constantly asks, "are we there yet..?" on a long car journey, that's polling.
When the unfortunate parent replies, "I'll tell you when we arrive" they are
creating a sort of callback (i.e. they promise to do something when some
condition is met). The <code>_run_once</code> method processes the
I/O events that occurred during the time it took to complete the
<em>previous</em> "lap", ensures any callbacks that need to be run are done so
during <em>this</em> lap and carries out "housekeeping" needed for callbacks
that have <em>yet to be called</em>.</p>

<p>Importantly, the pending callbacks are executed one after the other
- stopping the loop from continuing. In other words, the next "lap" cannot
start <em>until all the sequentially executed callbacks finish</em> (in some
sense).</p>

<p>I imagine you're thinking, "Hang on, I thought you said
<code>asyncio</code> works concurrently?" I did and it does. Here's the
problem: concurrency is hard and there's more than one way to do it. So it's
worth taking some time to examine why <code>asyncio</code> works in the
way that it does.</p>

<p>If concurrent tasks interact with a shared resource they run the risk of
interfering with each other. For example, task A reads a
record, task B reads the same record, both A and B change the retrieved
record in different ways, task B writes the record, then task A writes the
record (causing the changes made by task B to be lost). Such interactions
between indeterminate
"<a href="https://en.wikipedia.org/wiki/Thread_%28computer_science%29">threaded</a>"
tasks result in painfully hard-to-reproduce bugs and complicated
mechanisms required to mitigate such situations. This is bad because the
<a href="https://en.wikipedia.org/wiki/KISS_principle">KISS</a> (keep it
simple, stupid) principle is abandoned.</p>

<p>One solution is to program in a synchronous manner: tasks
executed one after the other so they have no chance to interfere with
each other. Such programs are easy to understand since they're simply
a deterministic sequential list of things to do: first A, then B,
followed by C and so on. Unfortunately, if A needs to wait for something, for
example, a reply from a machine on the network, then the whole program waits.
As a result, the program can't handle any other events that may occur
while it waits for A's network call to complete - in such a case,
the program is described as
"<a href="https://en.wikipedia.org/wiki/Blocking_%28computing%29">blocked</a>".
The program becomes potentially slow and unresponsive - an unacceptable
condition if we're writing something that needs to react quickly to things
(such as a server - precisely the sort of program <code>asyncio</code> is
intended to help with).</p>

<p>Because <code>asyncio</code> is event driven, network related I/O is
<em>non-blocking</em>. Instead of waiting for a reply from a network call
before continuing with a computation, programmers define callbacks to be run
only when the result of the network call becomes known. In the meantime,
the program continues to respond to other things: the event loop keeps polling
for and responding to network I/O events (such as when the reply to our
network call arrives and the specified callbacks are executed).</p>

<p>This may sound abstract and confusing but it's remarkably close to how we
make plans in real life: when <em>X</em> happens, do <em>Y</em>. More
concretely, "when the tumble dryer finishes, fold the clothes and put them
away". Here, "the tumble dryer finishes" is some <em>event</em> we're
expecting and "fold the clothes and put them away" is a callback that
specifies what to do when the event happens. Once this plan is made, we're
free to get on with other things <em>until</em> we discover the tumble dryer
has finished.</p>

<p>Furthermore, as humans we work on concurrent tasks in a similar
non-blocking manner. We skip between the things we need to do while we wait
for other things to happen: we know we'll have time to squeeze the orange
juice while the toast and eggs are cooking when we make breakfast. Put in a
programmatic way, execute B while waiting on the result of the network call
made by A.</p>

<p><img src="/static/images/breakfast.jpg" alt="Orange juice, toast and eggs"/></p>

<p>Such familiar concepts mean <code>asyncio</code> avoids potentially
confusing and complicated "threaded" concurrency while retaining the benefits
of strictly sequential code. In fact, the
<a href="http://legacy.python.org/dev/peps/pep-3156/">specification</a> for
<code>asyncio</code> states that callbacks are,</p>

<blockquote>[...] strictly serialized: one callback must finish before the
next one will be called. This is an important guarantee: when two or more
callbacks use or modify shared state, each callback is guaranteed that while
it is running, the shared state isn't changed by another callback.
</blockquote>

<p>Therefore, from a programmer's perspective, it is important to understand
<em>how</em> asynchronous concurrent tasks are created, how such tasks
<em>pause while waiting</em> for non-blocking I/O, and how the callbacks that
<em>handle the eventual results</em> are defined. In other words, you need to
understand coroutines, futures and tasks.</p>

<p>The <code>asyncio</code> module is helpfully simple about these
abstractions:</p>

<ul>
    <li><code>asyncio.coroutine</code> - a
    <a href="http://legacy.python.org/dev/peps/pep-0318/">decorator</a> that
    indicates a function is a coroutine. A coroutine is simply
    a type of
    <a href="http://legacy.python.org/dev/peps/pep-0255/">generator</a> that
    uses the <code>yield from</code>, <code>return</code> or
    <code>raise</code> syntax to generate results.</li>
    <li><code>asyncio.Future</code> - a class used to represent a result that
    may not be available yet. It is an abstraction of something that has yet
    to be realised. Callback functions that process the eventual result are
    added to instances of this class (like a sort of to-do list of functions
    to be executed when the result is known). If you're familiar with
    <a href="https://twistedmatrix.com/trac/">Twisted</a> they're called
    <em>deferreds</em> and elsewhere they're sometimes called
    <em>promises</em>.</li>
    <li><code>asyncio.Task</code> - a subclass of <code>asyncio.Future</code>
    that wraps a coroutine. The resulting object is realised when the
    coroutine completes.</li>
</ul>

<p>Let's examine each one of these abstractions in more detail:</p>

<p>A coroutine is a sort of generator function. A task defined
by a coroutine may be suspended; thus allowing the event loop to get on with
other things (as described above). The
<a href="http://legacy.python.org/dev/peps/pep-0380/"><code>yield from</code></a>
syntax is used to suspend a coroutine. A coroutine can <code>yield from</code>
other coroutines <em>or</em> instances of the <code>asyncio.Future</code>
class. When the <em>other</em>
coroutine has a result or the pending <code>Future</code> object is realised,
execution of the coroutine continues from the <code>yield from</code>
statement that originally suspended the coroutine (this is sometimes referred
to as re-entry). The result of a <code>yield from</code> statement will be
either the return value of the <em>other</em> coroutine or the result of the
<code>Future</code> instance. If the referenced coroutine
or <code>Future</code> instance raise an exception this will be propagated.
Ultimately, at the end of the <code>yield from</code> chain, will be a
coroutine that actually returns a result or raises an exception (rather than
yielding from some other coroutine).</p>

<p>A helpful (yet not entirely accurate) metaphor is the process of calling a
customer support line. Perhaps you want to know why your order for goods
is late. The person at the end of the phone explains they can't continue with
your query because they need to check something with their accounts
department. They promise to call you back. This pause is similar to the
<code>yield from</code> statement: they're suspending the work while they
wait for something else, thus allowing you to get on with other stuff. At some
point, their accounts department will provide a result and the customer
support agent will re-enter the process of handling your query and when
they're done, will fulfil their promise and give you a call (hopefully with
good news about your order).</p>

<p>The important concept to remember is that <code>yield from</code> suspends
coroutines pending a result so the event loop is able to get on with other
things. When the result becomes known, the coroutine resumes.</p>

<p>The following example (like many of the examples in this post, it's an
annotated modification of code in the
<a href="https://docs.python.org/3.4/library/asyncio-task.html#example-chain-coroutines">Python documentation</a>
on <code>asyncio</code>) illustrates these concepts by chaining coroutines
that ultimately add two numbers together:</p>

<p><pre><code class="python">"""
Two coroutines chained together.

The compute() coroutine is chained to the print_sum() coroutine. The
print_sum() coroutine waits until compute() is completed before it returns a
result.
"""
import asyncio


# Notice the decorator!
@asyncio.coroutine
def compute(x, y):
    print("Compute %s + %s ..." % (x, y))
    # Pause the coroutine for 1 second by yielding from asyncio's built in
    # sleep coroutine. This simulates the time taken by a non-blocking I/O
    # call. During this time the event loop can get on with other things.
    yield from asyncio.sleep(1.0)
    # Actually return a result!
    return x + y


@asyncio.coroutine
def print_sum(x, y):
    # Pause the coroutine until the compute() coroutine has a result.
    result = yield from compute(x, y)
    # The following print() function won't be called until there's a result.
    print("%s + %s = %s" % (x, y, result))


# Reference the event loop.
loop = asyncio.get_event_loop()
# Start the event loop and continue until print_sum() is complete.
loop.run_until_complete(print_sum(1, 2))
# Shut down the event loop.
loop.close()
</code></pre></p>

<p>Notice that the coroutines only execute when the loop's
<code>run_until_complete</code> method is called.
<a href="http://hg.python.org/cpython/file/4ab2d8fac52b/Lib/asyncio/base_events.py#l190">Under the hood</a>,
the coroutine is wrapped in a <code>Task</code> instance and a callback is
added to this task that
<a href="http://hg.python.org/cpython/file/4ab2d8fac52b/Lib/asyncio/base_events.py#l72">raises the appropriate exception</a> needed to stop the loop (since
the task is realised because the coroutine completed). The task instance is
conceptually the same as the promise the customer support agent gave to
call you back when they finished processing your query (in the helpful
yet inaccurate metaphor described above). The return value of
<code>run_until_complete</code> is the task's result or, in the event of a
problem, its exception will be raised. In this example, the result is
<code>None</code> (since <code>print_sum</code> doesn't actually return
anything to become the result of the task).</p>

<p>The following sequence diagram illustrates the flow of activity:</p>

<p><img src="/static/images/tulip_coro.png" alt="Sequence diagram of a coroutine"/></p>

<p>So far we've discovered that coroutines suspend and resume tasks in such
a way that the event loop can get on with other things. Yet this only
addresses how concurrent tasks co-exist through time given a single event
loop.  It doesn't tell us how to deal with the end result of such concurrent
tasks when they complete and the result of their computation becomes
known.</p>

<p>As has been already mentioned, the results of such pending concurrent
tasks are represented by instances of the <code>async.Future</code> class.
Callback functions are added to such instances via the
<code>add_done_callback</code> method. Callback functions have a single
argument: the <code>Future</code> instance to which they have been added.
They are executed when their <code>Future</code>'s result eventually becomes
known (we say the <code>Future</code> is resolved). Resolution involves
setting the result using the <code>set_result</code> method or, in the case
of a problem, setting the appropriate exception via
<code>set_exception</code>. The callback can access the
<code>Future</code>'s result (be it something valid or an exception) via the
<code>result</code> method: either the result will be returned or the
exception will be raised.</p>

<p>Another example (again, an annotated modification of code from the
<a href="https://docs.python.org/3.4/library/asyncio-task.html#example-future-with-run-forever">Python documentation</a>)
illustrates how this works:</p>

<p><pre><code class="python">"""
A future and coroutine interact. The future is resolved with the result of
the coroutine causing the specified callback to be executed.
"""
import asyncio


@asyncio.coroutine
def slow_operation(future):
    """
    This coroutine takes a future and resolves it when its own result is
    known
    """
    # Imagine a pause from some non-blocking network based I/O here.
    yield from asyncio.sleep(1)
    # Resolve the future with an arbitrary result (for the purposes of
    # illustration).
    future.set_result('A result set by the slow_operation coroutine!')


def got_result(future):
    """
    This function is a callback. Its only argument is the resolved future
    whose result it prints. It then causes the event loop to stop.
    """
    print(future.result())
    loop.stop()


# Get the instance of the event loop (also referenced in got_result).
loop = asyncio.get_event_loop()
# Instantiate the future we're going to use to represent the as-yet unknown
# result.
future = asyncio.Future()
# Wrap the coroutine in a task to schedule it for execution when the
# event loop starts.
asyncio.Task(slow_operation(future))
# Add the callback to the future. The callback will only be executed when the
# future is resolved by the coroutine. The future object is passed into the
# got_result callback.
future.add_done_callback(got_result)

# Run the event loop until loop.stop() is called (in got_result).
try:
    loop.run_forever()
finally:
    loop.close()
</code></pre></p>

<p>This example of futures and coroutines interacting probably feels awkward
(at least, it does to me). As a result, and because such interactions are so
fundamental to working with <code>asyncio</code>, one should use the
<code>asyncio.Task</code> class (a subclass of <code>asyncio.Future</code>)
to avoid such boilerplate code. The example above can be simplified and made
more readable as follows:</p>

<p><pre><code class="python">"""
A far simpler and easy-to-read way to do things!

A coroutine is wrapped in a Task instance. When the coroutine returns a result
the task is automatically resolved causing the specified callback to be
executed.
"""
import asyncio


@asyncio.coroutine
def slow_operation():
    """
    This coroutine *returns* an eventual result.
    """
    # Imagine a pause from some non-blocking network based I/O here.
    yield from asyncio.sleep(1)
    # A *lot* more conventional and no faffing about with future instances.
    return 'A return value from the slow_operation coroutine!'


def got_result(future):
    """
    This function is a callback. Its only argument is a resolved future
    whose result it prints. It then causes the event loop to stop.

    In this example, the resolved future is, in fact, a Task instance.
    """
    print(future.result())
    loop.stop()


# Get the instance of the event loop (also referenced in got_result).
loop = asyncio.get_event_loop()
# Wrap the coroutine in a task to schedule it for execution when the event
# loop starts.
task = asyncio.Task(slow_operation())
# Add the callback to the task. The callback will only be executed when the
# task is resolved by the coroutine. The task object is passed into the
# got_result callback.
task.add_done_callback(got_result)

# Run the event loop until loop.stop() is called (in got_result).
try:
    loop.run_forever()
finally:
    loop.close()
</code></pre></p>

<p>To my eyes, this is a lot more comprehensible, easier to read and far
simpler to write. The <code>Task</code> class also makes it trivial to execute
tasks in parallel, as the following example (again,
<a href="http://docs.python.org/3.4/library/asyncio-task.html?highlight=asyncio.sleep#example-parallel-execution-of-tasks">taken from the Python documentation</a>)
shows:</p>

<p><pre><code class="python">"""
Three tasks running the same factorial coroutine in parallel.
"""
import asyncio


@asyncio.coroutine
def factorial(name, number):
    """
    https://en.wikipedia.org/wiki/Factorial
    """
    f = 1
    for i in range(2, number+1):
        print("Task %s: Compute factorial(%s)..." % (name, i))
        yield from asyncio.sleep(1)
        f *= i
    print("Task %s: factorial(%s) = %s" % (name, number, f))


# Instantiating tasks doesn't cause the coroutine to be run. It merely
# schedules the tasks.
tasks = [
    asyncio.Task(factorial("A", 2)),
    asyncio.Task(factorial("B", 3)),
    asyncio.Task(factorial("C", 4)),
]


# Get the event loop and cause it to run until all the tasks are done.
loop = asyncio.get_event_loop()
loop.run_until_complete(asyncio.wait(tasks))
loop.close()
</code></pre></p>

<p>So far, all our examples have used the <code>asyncio.sleep</code> function
to simulate arbitrary amounts of time to represent the wait one might expect
for non-blocking network I/O. This is convenient for examples, but now that we
understand coroutines, futures and tasks we'd better examine how networking
fits into the picture.</p>

<p>There are two approaches one can take to network based operations: the
high level
<a href="https://docs.python.org/3.4/library/asyncio-stream.html">Streams</a>
API or the lower level
<a href="https://docs.python.org/3.4/library/asyncio-protocol.html">Transports
and Protocols</a> API. The following example (based on
<a href="https://docs.python.org/3.4/library/asyncio-stream.html#example">this original implementation</a>)
shows how a coroutine works with non-blocking network I/O in order to
retrieve HTTP headers using the stream based API:

<p><pre><code class="python">"""
Use a coroutine and the Streams API to get HTTP headers. Usage:

python headers.py http://example.com/path/page.html
"""
import asyncio
import urllib.parse
import sys


@asyncio.coroutine
def print_http_headers(url):
    url = urllib.parse.urlsplit(url)
    # An example of yielding from non-blocking network I/O.
    reader, writer = yield from asyncio.open_connection(url.hostname, 80)
    # Re-entry happens when the connection is made. The reader and writer
    # stream objects represent what you'd expect given their names.
    query = ('HEAD {url.path} HTTP/1.0\r\n'
             'Host: {url.hostname}\r\n'
             '\r\n').format(url=url)
    # Write data out (does not block).
    writer.write(query.encode('latin-1'))
    while True:
        # Another example of non-blocking network I/O for reading asynchronous
        # input.
        line = yield from reader.readline()
        if not line:
            break
        line = line.decode('latin1').rstrip()
        if line:
            print('HTTP header> %s' % line)


# None of the following should be at all surprising.
url = sys.argv[1]
loop = asyncio.get_event_loop()
task = asyncio.async(print_http_headers(url))
loop.run_until_complete(task)
loop.close()
</code></pre></p>

<p>Note how, instead of yielding from <code>asyncio.sleep</code>, the
coroutine yields from the built in <code>open_connection</code> and
<code>readline</code> coroutines that handle the asynchronous networking I/O.
Importantly, the call to <code>write</code> does not block, but buffers the
data and sends it out asynchronously.</p>

<p>The lower level API should feel familiar to anyone who has written code
using the <a href="https://twistedmatrix.com/">Twisted framework</a>. What
follows is a trivial server (based on
<a href="https://docs.python.org/3.4/library/asyncio-protocol.html#echo-server">this example</a>)
that uses transports and protocols.</p>

<p>Transports are classes provided by <code>asyncio</code> to abstract
<a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP</a>,
<a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a>,
<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">TLS/SSL</a>
and
<a href="https://en.wikipedia.org/wiki/Pipeline_%28Unix%29">subprocess pipes</a>.
Instances of such classes are responsible for the actual
I/O and buffering. However, you don't usually instantiate such classes
yourself; rather, you call the event loop instance to set things up (and
it'll call you back when it succeeds).</p>

<p>Once the connection is established, a
transport is always paired with an instance of the <code>Protocol</code>
class. You subclass <code>Protocol</code> to implement your own network
protocols; it parses incoming data and writes outgoing data by calling the
associated transport's methods for such purposes. Put simply, the
transport handles the sending and receiving of things down the wire, while
the protocol works out what the actual message means.</p>

<p>To implement a protocol override appropriate methods from the
<code>Protocol</code> parent class. Each time a connection is made (be it
incoming or outgoing) a new instance of the protocol is instantiated and
the various overridden methods are called depending on what network events
have been detected. For example, every protocol class will have its
<code>connection_made</code> and <code>connection_lost</code> methods
called when the connection begins and ends. Between these two calls one might
expect to handle <code>data_received</code> events and use the paired
<code>Transport</code> instance to send data. The following simple echo
server demonstrates the interaction between protocol and transport without
the distraction of coroutines and futures.</p>

<p><pre><code class="python">"""
A simple (yet poetic) echo server. ;-)

- ECHO -

Use your voice - say what you mean
Do not stand in the shadow
Do not become an echo of someone else's opinion
We must accept ourselves and each other
Even the perfect diamond
may have cracks and faults

A-L Andresen, 2014. (<a href="http://bit.ly/1nvhr8T">http://bit.ly/1nvhr8T</a>)
"""
import asyncio


class EchoProtocol(asyncio.Protocol):
    """
    Encapsulates the behaviour of the echo protocol. A new instance of this
    class is created for each new connection.
    """

    def connection_made(self, transport):
        """
        Called only once when the new connection is made. The transport
        argument represents the connection to the client.
        """
        self.transport = transport

    def data_received(self, data):
        """
        Called when the client sends data (represented by the data argument).
        """
        # Write the incoming data immediately back to the client connection.
        self.transport.write(data)
        # Calling self.transport.close() disconnects. If you want the
        # connection to persist simply comment out the following line.
        self.transport.close()


loop = asyncio.get_event_loop()
# Create the coroutine used to establish the server.
echo_coroutine = loop.create_server(EchoProtocol, '127.0.0.1', 8888)
# Run the coroutine to actually establish the server.
server = loop.run_until_complete(echo_coroutine)

try:
    # Run the event loop forever, waiting for new connections.
    loop.run_forever()
except KeyboardInterrupt:
    # Unless we get Ctrl-C keyboard interrupt.
    print('exit')
finally:
    # Stop serving (existing connections remain open).
    server.close()
    # Shut down the loop.
    loop.close()
</code></pre></p>

<p>An example interaction with this server using
<a href="https://en.wikipedia.org/wiki/Netcat">netcat</a>
is shown below:</p>

<p><pre><code>$ python echo.py &
[1] 7486
$ nc localhost 8888
Hello, World!
Hello, World!
$ fg
python echo.py
^Cexit
</code></pre></p>

<p>Yet, this only scratches the surface of <code>asyncio</code> and I'm
cherry-picking the parts that most interest me. If you want to find out more
the
<a href="https://docs.python.org/3.4/library/asyncio.html">Python documentation</a>
for the module is a great place to start, as is
<a href="http://legacy.python.org/dev/peps/pep-3156/">PEP 3156</a> used to
specify the module.</p>

<p>In conclusion <code>asyncio</code> feels like Twisted on a diet with the
added fun and elegance of coroutines. I've generally had good experiences
using Twisted but always felt uncomfortable with its odd naming conventions
(for example, calling the
<a href="https://twistedmatrix.com/trac/wiki/TwistedConch">secure shell implementation</a>
"conch" is the world's worst programming pun) and I suffer from an uneasy
feeling that it exists in a slightly different parallel Pythonic universe.
Personally, I feel <code>asyncio</code> is a step in the right direction
because such a lot of the "good stuff" from Twisted has made it into the
core language in a relatively small and obvious module. I'm also looking
forward to using it in my own projects (specifically,
<a href="http://drogul.us">the drogulus</a>).

<p>As I become more adept at using this module I may write up more.</p>

<p><small>Image credits:
<a href="https://flic.kr/p/8TQSAL">Breakfast</a>
&copy; 2010
<a href="https://secure.flickr.com/photos/pankaj/">Pankaj Kaushal</a>
under a
<a href="https://creativecommons.org/licenses/by-nc-nd/2.0/">Creative Commons</a>
License.
Sequence Diagram
<a href="https://docs.python.org/3.4/copyright.html">&copy; 2014</a>
<a href="http://python.org">The Python Software Foundation</a>.
</small></p>
<hr/>
<h1><a href="/article/autonomy">Autonomy</a></h1><p class="published_on">Monday 24th March (8:00AM)</p>

<p>I believe autonomy is important. I like to think I have personal autonomy.
I also think it important as a political end to be promoted by institutions
in our wider society.</p>

<p>This article is a reflection upon autonomy.</p>

<p>The etymology of "autonomy" is derived from Greek for "autos" (self) and
"nomos" (rule or law). It was originally applied to city states where citizens
were free to live by their own laws rather than laws imposed upon them.
Unsurprisingly,
<a href="http://www.dict.org/bin/Dict?Form=Dict2&Database=*&Query=autonomy">my dictionary</a>
defines autonomy as, "the power or right of self-government; self-government,
or political independence, of a city or a state".</p>

<p>However, it is personal autonomy, as applied to individuals, that I am
interested in exploring.</p>

<p>An autonomous person is, "obedient to a law that one prescribes to
oneself" (to paraphrase Rousseau). Such a person leads their life in a manner
that is consistent with a set of beliefs, values and principles that are the
outcome of reflection and self evaluation. As Socrates famously said, "the
unexamined life is not worth living". Furthermore, an autonomous person is
not only capable of considering, deciding and acting but <em>does so in all
three cases</em>. To act without self-reflection - perhaps out of habit or
because of an unthinking obedience to received "normal" modes of behaviour -
is not autonomy.</p>

<img src="/static/images/socrates.jpg" alt="Socrates"/>

<p>For someone to possess autonomy not only should they have the capacity for
self-reflection but they should have the additional two external requirements
of freedom to act without imposition and freedom to act according to their
principles. Perhaps the most famous description of such freedoms can be found
in Isiah Berlin's essay, "Two Concepts of Liberty" (Berlin uses the words
"freedom" and "liberty" interchangeably) in which he defines <em>positive</em>
and <em>negative</em> freedom.</p>

<p>Berlin introduces these concepts by relating each to a question:</p>

<blockquote>...the negative sense, is involved in the answer to the question
"What is the area within which the subject - a person or a group of persons -
is or should be left to do or be what he is able to do or be, without
interference by other persons?" The second, ...the positive sense, is involved
in the answer to the question "What or who, is the source of control or
interference that can determine someone to do, or be, this rather than that?"
</blockquote>

<p>Let's unpack these two aspects of freedom / liberty:</p>

<p>Put simply, negative liberty is <em>freedom from coercion or
interference</em>. Berlin qualifies this by claiming that coercion implies
deliberate interference from others. As Berlin puts it,

<blockquote>If I say I am unable to jump more than ten feet in the air [...]
it would be eccentric to say that I am to that degree enslaved or coerced. You
lack political liberty or freedom only if you are prevented from attaining the
goal by human beings.
</blockquote>

<p>In the context of autonomy, negative liberty affords the opportunity for
self reflection or decision making on one's own terms. As Berlin points out,
in a wider sense one's "freedom" to act may be limited by laws of nature but
this is not our focus. Rather, we're concerned with coercion interfering with
our intent to act in such-and-such a way.</p>

<p>Alternatively, positive liberty is the <em>freedom to act in a particular
way</em>. It is the capacity to act based upon one's own choices and reasons.
Berlin insists,</p>

<blockquote>I wish to be the instrument of my own, not of other men's acts of
will. I wish to be a subject, not an object; to be moved by reasons, by
conscious purposes, which are my own, not by causes which affect me, as it
were, from outside. I wish to be somebody, not nobody; a doer - deciding, not
by external nature or by other men as if I were a thing, or an animal, or a
slave incapable of playing a human role, that is, of conceiving goals and
policies of my own and realising them.
</blockquote>

<p>Put simply, one can be free from interference (negative liberty) and free
to act (positive liberty) and in order to act autonomously one of these
freedoms is required.</p>

<p>Why only one? It's possible to act autonomously but only enjoy one of the
two sorts of liberty. For example, I have the positive freedom to
choose to drive on the wrong side of the road, and, under certain rare
circumstances may choose to do so although I ought to expect curtailment of
my negative freedoms via coercion in the form of the police. Alternatively, I
may enjoy the negative liberty to be free from coercion when applying to
one or another university but the decision concerning my offer of a place
does not rest with me (a positive freedom to attend). It's the decision of
the institutions to which I applied.</p>

<p>But are these freedoms the same as autonomy?</p>

<p>No. The will to act is missing - the capacity to take advantage of such
liberties. Consider the following, as a result of misinformation,
misunderstanding, habit or deception a person may not realise they have
liberty to act in some way or another. Perhaps they come from a town where
there are "Keep off the Grass" signs in every park and so they mistakenly
believe that this rule is the case for their current location when no such
rule is advertised or even exists. They are at liberty to walk where they will
but don't because of their ignorance.</p>

<img src="/static/images/keepoffthegrass.jpg" title="Keep off the Grass!"/>

<p>Therefore, there is a need for an open, enquiring and imaginative mind used
to engaging in reflection in order to discover and decide to take advantage
of such liberties.</p>

<p>And so we come full circle back to the capacity for self-reflection.</p>

<p>Unsurprisingly, I believe such an outlook ought to be
encouraged at school, via institutions such as professional organisations and
facilitated by the technology we invent, build and deploy.</p>

<p>Autonomy can also be paradoxical: strangely, I may act autonomously to
curtail the freedoms needed to act autonomously. For example, I may freely
choose to join the army causing me to live a necessarily un-autonomous
life.</p>

<p>Furthermore, we regularly curtail our own and each other's autonomy in
order to act autonomously: this is perhaps best encapsulated in the term "wage
slave", a situation where one is forced to work in order to earn enough to pay
for some other thing perceived to be more valuable than one's current autonomy
(such as a mortgage, family holiday abroad or merely earning enough to make
ends meet).</p>

<p>More puzzling still, many are paid to curtail other people's autonomy: I'm
often asked to design software that is purposely limited until you pay money
- and even then it is only designed to work in a specific pre-defined
manner (for example, you have to pay to join a dating website, and even then,
you're limited by not being able to contact your potential dates directly).
This is politely (and mistakenly) called "business", but an (understandably)
cynical person would prefer the term "exploitation".</p>

<p>Finally, exercising personal autonomy is how we decide and act upon life's
big questions of a political, ethical and personal nature. It is this reason,
ultimately, that explains why I believe it to be such an important attribute.
It's also why the promotion of autonomy is the stated primary aim of
<a href="/article/build-a-drogulus">the drogulus</a>.</p>

<p><small>Image credits:
<a href="https://en.wikipedia.org/wiki/File:Socrates_Louvre.jpg">Socrates</a>.
&copy; 2005
<a href="https://fr.wikipedia.org/wiki/Utilisateur:Sting">Eric Gaba</a>
(under a
<a href="https://creativecommons.org/licenses/by-sa/2.5/deed.en">creative commons</a>
license).
<a href="https://www.flickr.com/photos/mirsasha/8236043793/">Keep off the Grass</a>. &copy; 2012
<a href="https://secure.flickr.com/photos/mirsasha/">Mirsasha</a> (under a
<a href="https://creativecommons.org/licenses/by-nc-nd/2.0/deed.en_GB">creative commons</a> license).
</small></p>
<p><a href="/articles">View all articles</a></p>
{% endblock content %}